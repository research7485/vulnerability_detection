Cwe,Folder,Palm_Description,Vulnerable,Ground_Ranking,Ground_Score,Ground_Desc,Id_of_description_1,Description_from_cwe_website_1,Score_1,Id_of_description_2,Description_from_cwe_website_2,Score_2,Id_of_description_3,Description_from_cwe_website_3,Score_3,Id_of_description_4,Description_from_cwe_website_4,Score_4,Id_of_description_5,Description_from_cwe_website_5,Score_5,Id_of_description_6,Description_from_cwe_website_6,Score_6,Id_of_description_7,Description_from_cwe_website_7,Score_7,Id_of_description_8,Description_from_cwe_website_8,Score_8,Id_of_description_9,Description_from_cwe_website_9,Score_9,Id_of_description_10,Description_from_cwe_website_10,Score_10
cwe-200,mitre-eg-2,"The login function logs in the user if the username and password are correct. It first checks if the username exists in the database. If it does, it then checks if the password matches the hashed password in the database. If both checks pass, the user is logged in and redirected to the success page.",False,,,,836,"The product records password hashes in a data store, receives a hash of a password from a client, and compares the supplied hash to the hash obtained from the data store.Some authentication mechanisms rely on the client to generate the hash for a password, possibly to reduce load on the server or avoid sending the password across the network. However, when the client is used to generate the hash, an attacker can bypass the authentication by obtaining a copy of the hash, e.g. by using SQL injection to compromise a database of authentication credentials, or by exploiting an information exposure. The attacker could then use a modified client to replay the stolen hash without having knowledge of the original password.
As a result, the server-side comparison against a client-side hash does not provide any more security than the use of passwords without hashing.",0.4705,523,Login pages do not use adequate measures to protect the user name and password while they are in transit from the client to the server.,0.4308,206,"The product performs multiple behaviors that are combined to produce a single result, but the individual behaviors are observable separately in a way that allows attackers to reveal internal state or internal decision points.Ideally, a product should provide as little information as possible to an attacker.  Any hints that the attacker may be making progress can then be used to simplify or optimize the attack.  For example, in a login procedure that requires a username and password, ultimately there is only one decision: success or failure.  However, internally, two separate actions are performed: determining if the username exists, and checking if the password is correct.  If the product behaves differently based on whether the username exists or not, then the attacker only needs to concentrate on the password.",0.3880,558,"The product uses the getlogin() function in a multithreaded context, potentially causing it to return incorrect values.The getlogin() function returns a pointer to a string that contains the name of the user associated with the calling process. The function is not reentrant, meaning that if it is called from another process, the contents are not locked out and the value of the string can be changed by another process. This makes it very risky to use because the username can be changed by other processes, so the results of the function cannot be trusted.",0.3765,1254,"The product's comparison logic is performed over a series of steps rather than across the entire string in one operation. If there is a comparison logic failure on one of these steps, the operation may be vulnerable to a timing attack that can result in the interception of the process for nefarious purposes.Comparison logic is used to compare a variety of objects including passwords, Message 
         Authentication Codes (MACs), and responses to verification challenges. When comparison logic is 
         implemented at a finer granularity (e.g., byte-by-byte comparison) and breaks in the case of a 
         comparison failure, an attacker can exploit this implementation to identify when exactly 
         the failure occurred. With multiple attempts, the attacker may be able to guesses the correct 
         password/response to challenge and elevate their privileges.",0.3737,393,"A function or operation returns an incorrect return value or status code that does not indicate an error, but causes the product to modify its behavior based on the incorrect result.This can lead to unpredictable behavior. If the function is used to make security-critical decisions or provide security-critical information, then the wrong status code can cause the product to assume that an action is safe, even when it is not.",0.3455,187,"The product performs a comparison that only examines a portion of a factor before determining whether there is a match, such as a substring, leading to resultant weaknesses.For example, an attacker might succeed in authentication by providing a small password that matches the associated portion of the larger, correct password.",0.3432,521,"The product does not require that users should have strong passwords, which makes it easier for attackers to compromise user accounts.Authentication mechanisms often rely on a memorized secret (also known as a password) to provide an assertion of identity for a user of a system. It is therefore important that this password be of sufficient complexity and impractical for an adversary to guess. The specific requirements around how complex a password needs to be depends on the type of system being protected. Selecting the correct password requirements and enforcing them through implementation are critical to the overall success of the authentication mechanism.",0.3394,778,"When a security-critical event occurs, the product either does not record the event or omits important details about the event when logging it.When security-critical events are not logged properly, such as a failed login attempt, this can make malicious behavior more difficult to detect and may hinder forensic analysis after an attack succeeds.
As organizations adopt cloud storage resources, these technologies often require configuration changes to enable detailed logging information, since detailed logging can incur additional costs. This could lead to telemetry gaps in critical audit logs. For example, in Azure, the default value for logging is disabled.",0.3348,565,"The product relies on the existence or values of cookies when performing security-critical operations, but it does not properly ensure that the setting is valid for the associated user.Attackers can easily modify cookies, within the browser or by implementing the client-side code outside of the browser. Reliance on cookies without detailed validation and integrity checking can allow attackers to bypass authentication, conduct injection attacks such as SQL injection and cross-site scripting, or otherwise modify inputs in unexpected ways.",0.3323
cwe-200,mitre-eg-6,"The info function displays sensitive information about the user, including username, e-mail, and ssn (last 4 digits).",True,59,0.2828,"The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.There are many different kinds of mistakes that introduce information exposures. The severity of the error can range widely, depending on the context in which the product operates, the type of sensitive information that is revealed, and the benefits it may provide to an attacker.  Some kinds of sensitive information include:
Information might be sensitive to different parties, each of which may have their own expectations for whether the information should be protected.  These parties include:
Information exposures can occur in different ways:
It is common practice to describe any loss of confidentiality as an ""information exposure,"" but this can lead to overuse of CWE-200 in CWE mapping. From the CWE perspective, loss of confidentiality is a technical impact that can arise from dozens of different weaknesses, such as insecure file permissions or out-of-bounds read.  CWE-200 and its lower-level descendants are intended to cover the mistakes that occur in behaviors that explicitly manage, store, transfer, or cleanse sensitive information.",202,"When trying to keep information confidential, an attacker can often infer some of the information by using statistics.In situations where data should not be tied to individual users, but a large number of users should be able to make queries that ""scrub"" the identity of users, it may be possible to get information about a user -- e.g., by specifying search terms that are known to be unique to that user.",0.5251,201,"The code transmits data to another actor, but a portion of the data includes sensitive information that should not be accessible to that actor.Sensitive information could include data that is sensitive in and of itself (such as credentials or private messages), or otherwise useful in the further exploitation of the system (such as internal file system structure).",0.4553,204,"The product provides different responses to incoming requests in a way that reveals internal state information to an unauthorized actor outside of the intended control sphere.This issue frequently occurs during authentication, where a difference in failed-login messages could allow an attacker to determine if the username is valid or not. These exposures can be inadvertent (bug) or intentional (design).",0.4334,507,"The product appears to contain benign or useful functionality, but it also contains code that is hidden from normal operation that violates the intended security policy of the user or the system administrator.",0.3994,357,"The user interface provides a warning to a user regarding dangerous or sensitive operations, but the warning is not noticeable enough to warrant attention.",0.3963,317,"The product stores sensitive information in cleartext within the GUI.An attacker can often obtain data from a GUI, even if hidden, by using an API to directly access GUI objects such as windows and menus. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information.",0.3808,451,"The user interface (UI) does not properly represent critical information to the user, allowing the information - or its source - to be obscured or spoofed. This is often a component in phishing attacks.If an attacker can cause the UI to display erroneous data, or to otherwise convince the user to display information that appears to come from a trusted source, then the attacker could trick the user into performing the wrong action. This is often a component in phishing attacks, but other kinds of problems exist. For example, if the UI is used to monitor the security state of a system or network, then omitting or obscuring an important indicator could prevent the user from detecting and reacting to a security-critical event.
UI misrepresentation can take many forms:",0.3749,315,"The product stores sensitive information in cleartext in a cookie.Attackers can use widely-available tools to view the cookie and read the sensitive information. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information.",0.3738,210,The product identifies an error condition and creates its own diagnostic or error messages that contain sensitive information.,0.3723,359,"The product does not properly prevent a person's private, personal information from being accessed by actors who either (1) are not explicitly authorized to access the information or (2) do not have the implicit consent of the person about whom the information is collected.There are many types of sensitive information that products must protect from attackers, including system data, communications, configuration, business secrets, intellectual property, and an individual's personal (private) information.  Private personal information may include a password, phone number, geographic location, personal messages, credit card number, etc.  Private information is important to consider whether the person is a user of the product, or part of a data set that is processed by the product.  An exposure of private information does not necessarily prevent the product from working properly, and in fact the exposure might be intended by the developer, e.g. as part of data sharing with other organizations.  However, the exposure of personal private information can still be undesirable or explicitly prohibited by law or regulation.
Some types of private information include:
Some of this information may be characterized as PII (Personally Identifiable Information), Protected Health Information (PHI), etc. Categories of private information may overlap or vary based on the intended usage or the policies and practices of a particular industry.
Sometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private.",0.3723
cwe-434,my-eg-1,The upload_pdf function saves the uploaded pdf file to the ./uploads directory.,True,12,0.2672,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,530,"A backup file is stored in a directory or archive that is made accessible to unauthorized actors.Often, older backup files are renamed with an extension such as .~bk to distinguish them from production files. The source code for old files that have been renamed in this manner and left in the webroot can often be retrieved. This renaming may have been performed automatically by the web server, or manually by the administrator.",0.4202,616,"The PHP application uses an old method for processing uploaded files by referencing the four global variables that are set for each file (e.g. $varname, $varname_size, $varname_name, $varname_type). These variables could be overwritten by attackers, causing the application to process unauthorized files.These global variables could be overwritten by POST requests, cookies, or other methods of populating or overwriting these variables. This could be used to read or process arbitrary files by providing values such as ""/etc/passwd"".",0.3701,646,"The product allows a file to be uploaded, but it relies on the file name or extension of the file to determine the appropriate behaviors. This could be used by attackers to cause the file to be misclassified and processed in a dangerous fashion.An application might use the file name or extension of a user-supplied file to determine the proper course of action, such as selecting the correct process to which control should be passed, deciding what data should be made available, or what resources should be allocated. If the attacker can cause the code to misclassify the supplied file, then the wrong action could occur. For example, an attacker could supply a file that ends in a "".php.gif"" extension that appears to be a GIF image, but would be processed as PHP code. In extreme cases, code execution is possible, but the attacker could also cause exhaustion of resources, denial of service, exposure of debug or system data (including application source code), or being bound to a particular server side process. This weakness may be due to a vulnerability in any of the technologies used by the web and application servers, due to misconfiguration, or resultant from another flaw in the application itself.",0.3629,,,,,,,,,,,,,,,,,,,,,
cwe-434,my-eg-3,The upload_file function saves uploaded files to the folder ./uploads if they are safe and if they are less than 2MB.,False,,,,616,"The PHP application uses an old method for processing uploaded files by referencing the four global variables that are set for each file (e.g. $varname, $varname_size, $varname_name, $varname_type). These variables could be overwritten by attackers, causing the application to process unauthorized files.These global variables could be overwritten by POST requests, cookies, or other methods of populating or overwriting these variables. This could be used to read or process arbitrary files by providing values such as ""/etc/passwd"".",0.4574,530,"A backup file is stored in a directory or archive that is made accessible to unauthorized actors.Often, older backup files are renamed with an extension such as .~bk to distinguish them from production files. The source code for old files that have been renamed in this manner and left in the webroot can often be retrieved. This renaming may have been performed automatically by the web server, or manually by the administrator.",0.4547,646,"The product allows a file to be uploaded, but it relies on the file name or extension of the file to determine the appropriate behaviors. This could be used by attackers to cause the file to be misclassified and processed in a dangerous fashion.An application might use the file name or extension of a user-supplied file to determine the proper course of action, such as selecting the correct process to which control should be passed, deciding what data should be made available, or what resources should be allocated. If the attacker can cause the code to misclassify the supplied file, then the wrong action could occur. For example, an attacker could supply a file that ends in a "".php.gif"" extension that appears to be a GIF image, but would be processed as PHP code. In extreme cases, code execution is possible, but the attacker could also cause exhaustion of resources, denial of service, exposure of debug or system data (including application source code), or being bound to a particular server side process. This weakness may be due to a vulnerability in any of the technologies used by the web and application servers, due to misconfiguration, or resultant from another flaw in the application itself.",0.4402,378,"Opening temporary files without appropriate measures or controls can leave the file, its contents and any function that it impacts vulnerable to attack.",0.3994,434,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,0.3821,433,"The product stores raw content or supporting code under the web document root with an extension that is not specifically handled by the server.If code is stored in a file with an extension such as "".inc"" or "".pl"", and the web server does not have a handler for that extension, then the server will likely send the contents of the file directly to the requester without the pre-processing that was expected. When that file contains sensitive information such as database credentials, this may allow the attacker to compromise the application or associated components.",0.3584,552,"The product makes files or directories accessible to unauthorized actors, even though they should not be.Web servers, FTP servers, and similar servers may store a set of files underneath a ""root"" directory that is accessible to the server's users.  Applications may store sensitive files underneath this root without also using access control to limit which users may request those files, if any.  Alternately, an application might package multiple files or directories into an archive file (e.g., ZIP or tar), but the application might not exclude sensitive files that are underneath those directories.
In cloud technologies and containers, this weakness might present itself in the form of misconfigured storage accounts that can be read or written by a public or anonymous user.",0.3536,46,"The product accepts path input in the form of trailing space ('filedir ') without appropriate validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.",0.3500,42,"The product accepts path input in the form of trailing dot ('filedir.') without appropriate validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.",0.3461,54,"The product accepts path input in the form of trailing backslash ('filedir\') without appropriate validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.",0.3447
cwe-434,my-eg-2,The upload_image function saves uploaded images to the database base64 encoded. It also ensures that they are jpg images less than 1024kb in size.,True,7,0.3162,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,616,"The PHP application uses an old method for processing uploaded files by referencing the four global variables that are set for each file (e.g. $varname, $varname_size, $varname_name, $varname_type). These variables could be overwritten by attackers, causing the application to process unauthorized files.These global variables could be overwritten by POST requests, cookies, or other methods of populating or overwriting these variables. This could be used to read or process arbitrary files by providing values such as ""/etc/passwd"".",0.4341,646,"The product allows a file to be uploaded, but it relies on the file name or extension of the file to determine the appropriate behaviors. This could be used by attackers to cause the file to be misclassified and processed in a dangerous fashion.An application might use the file name or extension of a user-supplied file to determine the proper course of action, such as selecting the correct process to which control should be passed, deciding what data should be made available, or what resources should be allocated. If the attacker can cause the code to misclassify the supplied file, then the wrong action could occur. For example, an attacker could supply a file that ends in a "".php.gif"" extension that appears to be a GIF image, but would be processed as PHP code. In extreme cases, code execution is possible, but the attacker could also cause exhaustion of resources, denial of service, exposure of debug or system data (including application source code), or being bound to a particular server side process. This weakness may be due to a vulnerability in any of the technologies used by the web and application servers, due to misconfiguration, or resultant from another flaw in the application itself.",0.3892,530,"A backup file is stored in a directory or archive that is made accessible to unauthorized actors.Often, older backup files are renamed with an extension such as .~bk to distinguish them from production files. The source code for old files that have been renamed in this manner and left in the webroot can often be retrieved. This renaming may have been performed automatically by the web server, or manually by the administrator.",0.3672,789,"The product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.",0.3582,515,"A covert storage channel transfers information through the setting of bits by one program and the reading of those bits by another. What distinguishes this case from that of ordinary operation is that the bits are used to convey encoded information.Covert storage channels occur when out-of-band data is stored in messages for the purpose of memory reuse. Covert channels are frequently classified as either storage or timing channels. Examples would include using a file intended to hold only audit information to convey user passwords--using the name of a file or perhaps status bits associated with it that can be read by all users to signal the contents of the file. Steganography, concealing information in such a manner that no one but the intended recipient knows of the existence of the message, is a good example of a covert storage channel.",0.3261,,,,,,,,,,,,,,,
cwe-787,mitre-eg-2,"The main function allocates two chunks of memory, each of size 10. It then checks to make sure that the first chunk is larger than the second chunk. If it is, the program exits with an error. Otherwise, the main function copies the contents of the first chunk into the second chunk.",False,,,,466,A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.,0.5445,805,"The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.When the length value exceeds the size of the destination, a buffer overflow could occur.",0.5334,680,"The product performs a calculation to determine how much memory to allocate, but an integer overflow can occur that causes less memory to be allocated than expected, leading to a buffer overflow.",0.5250,562,"A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced.",0.5189,469,"The product subtracts one pointer from another in order to determine size, but this calculation can be incorrect if the pointers do not exist in the same memory chunk.",0.5063,787,"The product writes data past the end, or before the beginning, of the intended buffer.Typically, this can result in corruption of data, a crash, or code execution.  The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer.  A subsequent write operation then produces undefined or unexpected results.",0.5049,674,"The product does not properly control the amount of recursion that takes place,  consuming excessive resources, such as allocated memory or the program stack.",0.5031,762,"The product attempts to return a memory resource to the system, but it calls a release function that is not compatible with the function that was originally used to allocate that resource.This weakness can be generally described as mismatching memory management routines, such as:
When the memory management functions are mismatched, the consequences may be as severe as code execution, memory corruption, or program crash. Consequences and ease of exploit will vary depending on the implementation of the routines and the object being managed.",0.4942,823,"The product performs pointer arithmetic on a valid pointer, but it uses an offset that can point outside of the intended range of valid memory locations for the resulting pointer.While a pointer can contain a reference to any arbitrary memory location, a program typically only intends to use the pointer to access limited portions of memory, such as contiguous memory used to access an individual array.
Programs may use offsets in order to access fields or sub-elements stored within structured data. The offset might be out-of-range if it comes from an untrusted source, is the result of an incorrect calculation, or occurs because of another error.
If an attacker can control or influence the offset so that it points outside of the intended boundaries of the structure, then the attacker may be able to read or write to memory locations that are used elsewhere in the product. As a result, the attack might change the state of the product as accessed through program variables, cause a crash or instable behavior, and possibly lead to code execution.",0.4903,789,"The product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.",0.4890
cwe-787,mitre-eg-5,"The main function does the following:

1. Checks if the user provided 1 argument.
2. Gets the argument.
3. Prints the argument.
4. Trims the trailing whitespace.
5. Makes sure it is a hex string.
6. Prints the new length.
7. Trims the slashes and new lines.
8. Prints the new length.
9. Null terminates the string.
10. Prints the string.",False,,,,28,"The product uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize ""..\"" sequences that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.
The '..\' manipulation is the canonical manipulation for operating systems that use ""\"" as directory separators, such as Windows. However, it is also useful for bypassing path traversal protection schemes that only assume that the ""/"" separator is valid.",0.3414,34,"The product uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize '....//' (doubled dot dot slash) sequences that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.
The '....//' manipulation is useful for bypassing some path traversal protection schemes. If ""../"" is filtered in a sequential fashion, as done by some regular expression engines, then ""....//"" can collapse into the ""../"" unsafe value (CWE-182). It could also be useful when "".."" is removed, if the operating system treats ""//"" and ""/"" as equivalent.",0.3343,135,The product does not correctly calculate the length of strings that can contain wide or multi-byte characters.,0.3204,482,"The code uses an operator for comparison when the intention was to perform an assignment.In many languages, the compare statement is very close in appearance to the assignment statement; they are often confused.",0.3201,,,,,,,,,,,,,,,,,,
cwe-787,codeql-eg-PotentialBufferOverflow,The main function in this code generates three random floats and converts them to strings.,True,39,0.2157,"The product writes data past the end, or before the beginning, of the intended buffer.Typically, this can result in corruption of data, a crash, or code execution.  The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer.  A subsequent write operation then produces undefined or unexpected results.",1241,The device uses an algorithm that is predictable and generates a pseudo-random number.,0.4442,340,The product uses a scheme that generates numbers or identifiers that are more predictable than required.,0.3630,1046,"The product creates an immutable text string using string concatenation operations.When building a string via a looping feature (e.g., a FOR or WHILE loop), the use of += to append to the existing string will result in the creation of a new object with each iteration. This programming pattern can be inefficient in comparison with use of text buffer data elements. This issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this could be influenced to create performance problem.",0.3558,331,"The product uses an algorithm or scheme that produces insufficient entropy, leaving patterns or clusters of values that are more likely to occur than others.",0.3478,334,"The number of possible random values is smaller than needed by the product, making it more susceptible to brute force attacks.",0.3387,336,"A Pseudo-Random Number Generator (PRNG) uses the same seed each time the product is initialized.Given the deterministic nature of PRNGs, using the same seed for each initialization will lead to the same output in the same order. If an attacker can guess (or knows) the seed, then the attacker may be able to determine the random numbers that will be produced from the PRNG.",0.3275,343,"The product's random number generator produces a series of values which, when observed, can be used to infer a relatively small range of possibilities for the next value that could be generated.The output of a random number generator should not be predictable based on observations of previous values. In some cases, an attacker cannot predict the exact value that will be produced next, but can narrow down the possibilities significantly. This reduces the amount of effort to perform a brute force attack. For example, suppose the product generates random numbers between 1 and 100, but it always produces a larger value until it reaches 100. If the generator produces an 80, then the attacker knows that the next value will be somewhere between 81 and 100. Instead of 100 possibilities, the attacker only needs to consider 20.",0.3257,,,,,,,,,
cwe-125,my-2,"The getIdFromArray function returns the value at the given index in the array of ids. If the index is out of bounds, the function returns -1.",False,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
cwe-125,my-1,"The main function prompts the user to enter an index value and then checks if the value is in bounds. If it is, the function returns the value at the index in the id_sequence array. If the value is not in bounds, the function returns -1.",False,,,,562,"A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced.",0.3740,253,"The product incorrectly checks a return value from a function, which prevents it from detecting errors or exceptional conditions.Important and common functions will return some value about the success of its actions. This will alert the program whether or not to handle any errors caused by that function.",0.3706,482,"The code uses an operator for comparison when the intention was to perform an assignment.In many languages, the compare statement is very close in appearance to the assignment statement; they are often confused.",0.3684,393,"A function or operation returns an incorrect return value or status code that does not indicate an error, but causes the product to modify its behavior based on the incorrect result.This can lead to unpredictable behavior. If the function is used to make security-critical decisions or provide security-critical information, then the wrong status code can cause the product to assume that an action is safe, even when it is not.",0.3646,481,"The code uses an operator for assignment when the intention was to perform a comparison.In many languages the compare statement is very close in appearance to the assignment statement and are often confused. This bug is generally the result of a typo and usually causes obvious problems with program execution. If the comparison is in an if statement, the if statement will usually evaluate the value of the right-hand side of the predicate.",0.3485,786,"The product reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",0.3428,231,The product does not handle or incorrectly handles when more values are provided than expected.,0.3390,1283,"The register contents used for attestation or measurement reporting data to verify boot flow are modifiable by an adversary.A System-on-Chip (SoC) implements secure boot or verified boot. During this boot flow, the SoC often measures the code that it authenticates. The measurement is usually done by calculating the one-way hash of the code binary and extending it to the previous hash. The hashing algorithm should be a Secure One-Way hash function. The final hash, i.e., the value obtained after the completion of the boot flow, serves as the measurement data used in reporting or in attestation. The calculated hash is often stored in registers that can later be read by the party of interest to determine tampering of the boot flow. A common weakness is that the contents in these registers are modifiable by an adversary, thus spoofing the measurement.",0.3334,129,"The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",0.3295,252,"The product does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions.Two common programmer assumptions are ""this function call can never fail"" and ""it doesn't matter if this function call fails"". If an attacker can force the function to fail or otherwise return a value that is not expected, then the subsequent program logic could lead to a vulnerability, because the product is not in a state that the programmer assumes. For example, if the program calls a function to drop privileges but does not check the return code to ensure that privileges were successfully dropped, then the program will continue to operate with the higher privileges.",0.3293
cwe-125,mitre-eg-1,"The getValueFromArray function takes an array of integers, the size of the array, and an index as input. It returns the value at the given index if the index is within bounds, and -1 otherwise.",False,,,,1335,"An integer value is specified to be shifted by a negative amount or an amount greater than or equal to the number of bits contained in the value causing an unexpected or indeterminate result.Specifying a value to be shifted by a negative amount is undefined in various languages. Various computer architectures implement this action in different ways. The compilers and interpreters when generating code to accomplish a shift generally do not do a check for this issue.
Specifying an over-shift, a shift greater than or equal to the number of bits contained in a value to be shifted, produces a result which varies by architecture and compiler. In some languages, this action is specifically listed as producing an undefined result.",0.3981,466,A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.,0.3646,1077,"The code performs a comparison such as an
        equality test between two float (floating point) values, but
        it uses comparison operators that do not account for the
        possibility of loss of precision.Numeric calculation using floating point values
	   can generate imprecise results because of rounding errors.
	   As a result, two different calculations might generate
	   numbers that are mathematically equal, but have slightly
	   different bit representations that do not translate to the
	   same mathematically-equal values.  As a result, an equality
	   test or other comparison might produce unexpected
	   results.
This issue can prevent the product from running reliably.  If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",0.3502,393,"A function or operation returns an incorrect return value or status code that does not indicate an error, but causes the product to modify its behavior based on the incorrect result.This can lead to unpredictable behavior. If the function is used to make security-critical decisions or provide security-critical information, then the wrong status code can cause the product to assume that an action is safe, even when it is not.",0.3466,242,"The product calls a function that can never be guaranteed to work safely.Certain functions behave in dangerous ways regardless of how they are used. Functions in this category were often implemented without taking security concerns into account. The gets() function is unsafe because it does not perform bounds checking on the size of its input. An attacker can easily send arbitrarily-sized input to gets() and overflow the destination buffer. Similarly, the >> operator is unsafe to use when reading into a statically-allocated character array because it does not perform bounds checking on the size of its input. An attacker can easily send arbitrarily-sized input to the >> operator and overflow the destination buffer.",0.3411,839,"The product checks a value to ensure that it is less than or equal to a maximum, but it does not also verify that the value is greater than or equal to the minimum.Some products use signed integers or floats even when their values are only expected to be positive or 0. An input validation check might assume that the value is positive, and only check for the maximum value. If the value is negative, but the code assumes that the value is positive, this can produce an error. The error may have security consequences if the negative value is used for memory allocation, array access, buffer access, etc. Ultimately, the error could lead to a buffer overflow or other type of memory corruption.
The use of a negative number in a positive-only context could have security implications for other types of resources. For example, a shopping cart might check that the user is not requesting more than 10 items, but a request for -3 items could cause the application to calculate a negative price and credit the attacker's account.",0.3332,562,"A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced.",0.3329,195,"The product uses a signed primitive and performs a cast to an unsigned primitive, which can produce an unexpected value if the value of the signed primitive can not be represented using an unsigned primitive.It is dangerous to rely on implicit casts between signed and unsigned numbers because the result can take on an unexpected value and violate assumptions made by the program.
Often, functions will return negative values to indicate a failure. When the result of a function is to be used as a size parameter, using these negative return values can have unexpected results. For example, if negative size values are passed to the standard memory copy or allocation functions they will be implicitly cast to a large unsigned value. This may lead to an exploitable buffer overflow or underflow condition.",0.3242,193,"A product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.",0.3213,129,"The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",0.3212
cwe-732,codeql-eg-DoNotCreateWorldWriteable-a,"   return 0;
} The main function saves the important config to a file.",False,,,,378,"Opening temporary files without appropriate measures or controls can leave the file, its contents and any function that it impacts vulnerable to attack.",0.3472,13,Storing a plaintext password in a configuration file allows anyone who can read the file access to the password-protected resource making them an easy target for attackers.,0.3334,910,"The product uses or accesses a file descriptor after it has been closed.After a file descriptor for a particular file or device has been released, it can be reused. The code might not write to the original file, since the reused file descriptor might reference a different file or device.",0.3204,,,,,,,,,,,,,,,,,,,,,
cwe-732,codeql-eg-DoNotCreateWorldWriteable-b,"The main function saves the important config to a file, ensuring it is not world-writable.",False,,,,13,Storing a plaintext password in a configuration file allows anyone who can read the file access to the password-protected resource making them an easy target for attackers.,0.4525,1112,"The document does not fully define all mechanisms that are used
					to control or influence how product-specific programs are
					executed.This includes environmental variables, configuration files, registry keys, command-line switches or options, or system settings.",0.3972,1234,"System configuration protection may be bypassed during debug mode.Device configuration controls are commonly programmed after a device power reset by a trusted firmware or software module (e.g., BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set, disables writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration). If debug features supported by hardware or internal modes/system states are supported in the hardware design, modification of the lock protection may be allowed allowing access and modification of configuration information.",0.3700,1108,"The code is structured in a way that relies too much on using
					or setting global variables throughout various points in the code, instead of
					preserving the associated information in a narrower, more local
					context.This issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities.  It also might make it easier to introduce vulnerabilities.",0.3589,616,"The PHP application uses an old method for processing uploaded files by referencing the four global variables that are set for each file (e.g. $varname, $varname_size, $varname_name, $varname_type). These variables could be overwritten by attackers, causing the application to process unauthorized files.These global variables could be overwritten by POST requests, cookies, or other methods of populating or overwriting these variables. This could be used to read or process arbitrary files by providing values such as ""/etc/passwd"".",0.3577,15,"One or more system settings or configuration elements can be externally controlled by a user.Allowing external control of system settings can disrupt service or cause an application to behave in unexpected, and potentially malicious ways.",0.3361,541,"If an include file source is accessible, the file can contain usernames and passwords, as well as sensitive information pertaining to the application and system.",0.3357,555,"The J2EE application stores a plaintext password in a configuration file.Storing a plaintext password in a configuration file allows anyone who can read the file to access the password-protected resource, making it an easy target for attackers.",0.3356,378,"Opening temporary files without appropriate measures or controls can leave the file, its contents and any function that it impacts vulnerable to attack.",0.3325,433,"The product stores raw content or supporting code under the web document root with an extension that is not specifically handled by the server.If code is stored in a file with an extension such as "".inc"" or "".pl"", and the web server does not have a handler for that extension, then the server will likely send the contents of the file directly to the requester without the pre-processing that was expected. When that file contains sensitive information such as database credentials, this may allow the attacker to compromise the application or associated components.",0.3323
cwe-732,codeql-eg-WeakFilePermissions,"This program saves a super secret string to a file called ""secret.txt"" and then sets restricted permissions on the file so that only the owner can read it.",False,,,,13,Storing a plaintext password in a configuration file allows anyone who can read the file access to the password-protected resource making them an easy target for attackers.,0.5293,541,"If an include file source is accessible, the file can contain usernames and passwords, as well as sensitive information pertaining to the application and system.",0.4899,428,"The product uses a search path that contains an unquoted element, in which the element contains whitespace or other separators. This can cause the product to access resources in a parent path.If a malicious individual has access to the file system, it is possible to elevate privileges by inserting such a file as ""C:\Program.exe"" to be run by a privileged program making use of WinExec.",0.4754,64,"The product, when opening a file or directory, does not sufficiently handle when the file is a Windows shortcut (.LNK) whose target is outside of the intended control sphere. This could allow an attacker to cause the product to operate on unauthorized files.The shortcut (file with the .lnk extension) can permit an attacker to read/write a file that they originally did not have permissions to access.",0.4479,57,"The product contains protection mechanisms to restrict access to 'realdir/filename', but it constructs pathnames using external input in the form of 'fakedir/../realdir/filename' that are not handled by those mechanisms. This allows attackers to perform unauthorized actions against the targeted file.",0.4132,1386,"The product opens a file or directory, but it does not properly prevent the name from being associated with a junction or mount point to a destination that is outside of the intended control sphere.Depending on the intended action
			  being performed, this could allow an
			  attacker to cause the product to read,
			  write, delete, or otherwise operate on
			  unauthorized files.
In Windows, NTFS5 allows for file
			  system objects called reparse points.
			  Applications can create a hard link from one
			  directory to another directory, called a
			  junction point. They can also create a
			  mapping from a directory to a drive letter,
			  called a mount point. If a file is used by a
			  privileged program, but it can be replaced
			  with a hard link to a sensitive file (e.g.,
			  AUTOEXEC.BAT), an attacker could excalate
			  privileges. When the process opens the file,
			  the attacker can assume the privileges of
			  that process, tricking the privileged
			  process to read, modify, or delete the
			  sensitive file, preventing the program from
			  accurately processing data. Note that one
			  can also point to registries and
			  semaphores.",0.4085,313,"The product stores sensitive information in cleartext in a file, or on disk.The sensitive information could be read by attackers with access to the file, or with physical or administrator access to the raw disk. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information.",0.4050,379,"The product creates a temporary file in a directory whose permissions allow unintended actors to determine the file's existence or otherwise access that file.On some operating systems, the fact that the temporary file exists may be apparent to any user with sufficient privileges to access that directory. Since the file is visible, the application that is using the temporary file could be known. If one has access to list the processes on the system, the attacker has gained information about what the user is doing at that time. By correlating this with the applications the user is running, an attacker could potentially discover what a user's actions are. From this, higher levels of security could be breached.",0.4050,65,"The product, when opening a file or directory, does not sufficiently handle when the name is associated with a hard link to a target that is outside of the intended control sphere. This could allow an attacker to cause the product to operate on unauthorized files.Failure for a system to check for hard links can result in vulnerability to different types of attacks. For example, an attacker can escalate their privileges if a file used by a privileged program is replaced with a hard link to a sensitive file (e.g. AUTOEXEC.BAT). When the process opens the file, the attacker can assume the privileges of that process, or prevent the program from accurately processing data.",0.4045,318,"The product stores sensitive information in cleartext in an executable.Attackers can reverse engineer binary code to obtain secret data. This is especially easy when the cleartext is plain ASCII. Even if the information is encoded in a way that is not human-readable, certain techniques could determine which encoding is being used, then decode the information.",0.3992
cwe-190,mitre-eg-4,The main function in this program sums the number of sales for each quarter of the year and prints the results to the console.,True,45,0.2090,"The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.An integer overflow or wraparound occurs when an integer value is incremented to a value that is too large to store in the associated representation. When this occurs, the value may wrap to become a very small or negative number. While this may be intended behavior in circumstances that rely on wrapping, it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs. This becomes security-critical when the result is used to control looping, make a security decision, or determine the offset or size in behaviors such as memory allocation, copying, concatenation, etc.",253,"The product incorrectly checks a return value from a function, which prevents it from detecting errors or exceptional conditions.Important and common functions will return some value about the success of its actions. This will alert the program whether or not to handle any errors caused by that function.",0.3352,193,"A product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.",0.3228,,,,,,,,,,,,,,,,,,,,,,,,
cwe-190,codeql-eg-ArithmeticTainted,"The main function reads in the value from the command line, adds 1000 to it, and prints the result.",True,45,0.2482,"The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.An integer overflow or wraparound occurs when an integer value is incremented to a value that is too large to store in the associated representation. When this occurs, the value may wrap to become a very small or negative number. While this may be intended behavior in circumstances that rely on wrapping, it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs. This becomes security-critical when the result is used to control looping, make a security decision, or determine the offset or size in behaviors such as memory allocation, copying, concatenation, etc.",231,The product does not handle or incorrectly handles when more values are provided than expected.,0.4217,674,"The product does not properly control the amount of recursion that takes place,  consuming excessive resources, such as allocated memory or the program stack.",0.3295,680,"The product performs a calculation to determine how much memory to allocate, but an integer overflow can occur that causes less memory to be allocated than expected, leading to a buffer overflow.",0.3267,193,"A product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.",0.3217,562,"A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced.",0.3190,,,,,,,,,,,,,,,
cwe-190,codeql-eg-ArithmeticUncontrolled,The main function in this code generates two random integers larger than 1000.,False,,,,1241,The device uses an algorithm that is predictable and generates a pseudo-random number.,0.5413,334,"The number of possible random values is smaller than needed by the product, making it more susceptible to brute force attacks.",0.4833,343,"The product's random number generator produces a series of values which, when observed, can be used to infer a relatively small range of possibilities for the next value that could be generated.The output of a random number generator should not be predictable based on observations of previous values. In some cases, an attacker cannot predict the exact value that will be produced next, but can narrow down the possibilities significantly. This reduces the amount of effort to perform a brute force attack. For example, suppose the product generates random numbers between 1 and 100, but it always produces a larger value until it reaches 100. If the generator produces an 80, then the attacker knows that the next value will be somewhere between 81 and 100. Instead of 100 possibilities, the attacker only needs to consider 20.",0.4350,340,The product uses a scheme that generates numbers or identifiers that are more predictable than required.,0.3949,331,"The product uses an algorithm or scheme that produces insufficient entropy, leaving patterns or clusters of values that are more likely to occur than others.",0.3926,336,"A Pseudo-Random Number Generator (PRNG) uses the same seed each time the product is initialized.Given the deterministic nature of PRNGs, using the same seed for each initialization will lead to the same output in the same order. If an attacker can guess (or knows) the seed, then the attacker may be able to determine the random numbers that will be produced from the PRNG.",0.3858,332,"The lack of entropy available for, or used by, a Pseudo-Random Number Generator (PRNG) can be a stability and security threat.",0.3738,339,"A Pseudo-Random Number Generator (PRNG) uses a relatively small seed space, which makes it more susceptible to brute force attacks.PRNGs are entirely deterministic once seeded, so it should be extremely difficult to guess the seed. If an attacker can collect the outputs of a PRNG and then brute force the seed by trying every possibility to see which seed matches the observed output, then the attacker will know the output of any subsequent calls to the PRNG. A small seed space implies that the attacker will have far fewer possible values to try to exhaust all possibilities.",0.3560,333,True random number generators (TRNG) generally have a limited source of entropy and therefore can fail or block.The rate at which true random numbers can be generated is limited. It is important that one uses them only when they are needed for security.,0.3549,337,"A Pseudo-Random Number Generator (PRNG) is initialized from a predictable seed, such as the process ID or system time.The use of predictable seeds significantly reduces the number of possible seeds that an attacker would need to test in order to predict which random numbers will be generated by the PRNG.",0.3426
cwe-22,codeql-eg-TarSlip,This program unzips the tar file to /tmp/unpack.,True,62,0.1672,"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.Many file operations are intended to take place within a restricted directory. By using special elements such as "".."" and ""/"" separators, attackers can escape outside of the restricted location to access files or directories that are elsewhere on the system. One of the most common special elements is the ""../"" sequence, which in most modern operating systems is interpreted as the parent directory of the current location. This is referred to as relative path traversal. Path traversal also covers the use of absolute pathnames such as ""/usr/local/bin"", which may also be useful in accessing unexpected files. This is referred to as absolute path traversal.
In many programming languages, the injection of a null byte (the 0 or NUL) may allow an attacker to truncate a generated filename to widen the scope of attack. For example, the product may add "".txt"" to any pathname, thus limiting the attacker to text files, but a null injection may effectively remove this restriction.",378,"Opening temporary files without appropriate measures or controls can leave the file, its contents and any function that it impacts vulnerable to attack.",0.3424,528,"The product generates a core dump file in a directory, archive, or other resource that is stored, transferred, or otherwise made accessible to unauthorized actors.",0.3400,459,"The product does not properly ""clean up"" and remove temporary or supporting resources after they have been used.",0.3239,,,,,,,,,,,,,,,,,,,,,
cwe-22,codeql-eg-Python-TaintedPath,The img function returns the image file with the name specified in the GET variable.,True,45,0.1765,"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.Many file operations are intended to take place within a restricted directory. By using special elements such as "".."" and ""/"" separators, attackers can escape outside of the restricted location to access files or directories that are elsewhere on the system. One of the most common special elements is the ""../"" sequence, which in most modern operating systems is interpreted as the parent directory of the current location. This is referred to as relative path traversal. Path traversal also covers the use of absolute pathnames such as ""/usr/local/bin"", which may also be useful in accessing unexpected files. This is referred to as absolute path traversal.
In many programming languages, the injection of a null byte (the 0 or NUL) may allow an attacker to truncate a generated filename to widen the scope of attack. For example, the product may add "".txt"" to any pathname, thus limiting the attacker to text files, but a null injection may effectively remove this restriction.",82,"The web application does not neutralize or incorrectly neutralizes scripting elements within attributes of HTML IMG tags, such as the src attribute.Attackers can embed XSS exploits into the values for IMG attributes (e.g. SRC) that is streamed and then executed in a victim's browser. Note that when the page is loaded into a user's browsers, the exploit will automatically execute.",0.3692,,,,,,,,,,,,,,,,,,,,,,,,,,,
cwe-22,codeql-eg-C-TaintedPath,The main function reads the requested file from the safe directory.,True,52,0.3240,"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.Many file operations are intended to take place within a restricted directory. By using special elements such as "".."" and ""/"" separators, attackers can escape outside of the restricted location to access files or directories that are elsewhere on the system. One of the most common special elements is the ""../"" sequence, which in most modern operating systems is interpreted as the parent directory of the current location. This is referred to as relative path traversal. Path traversal also covers the use of absolute pathnames such as ""/usr/local/bin"", which may also be useful in accessing unexpected files. This is referred to as absolute path traversal.
In many programming languages, the injection of a null byte (the 0 or NUL) may allow an attacker to truncate a generated filename to widen the scope of attack. For example, the product may add "".txt"" to any pathname, thus limiting the attacker to text files, but a null injection may effectively remove this restriction.",378,"Opening temporary files without appropriate measures or controls can leave the file, its contents and any function that it impacts vulnerable to attack.",0.4933,433,"The product stores raw content or supporting code under the web document root with an extension that is not specifically handled by the server.If code is stored in a file with an extension such as "".inc"" or "".pl"", and the web server does not have a handler for that extension, then the server will likely send the contents of the file directly to the requester without the pre-processing that was expected. When that file contains sensitive information such as database credentials, this may allow the attacker to compromise the application or associated components.",0.4578,541,"If an include file source is accessible, the file can contain usernames and passwords, as well as sensitive information pertaining to the application and system.",0.4308,65,"The product, when opening a file or directory, does not sufficiently handle when the name is associated with a hard link to a target that is outside of the intended control sphere. This could allow an attacker to cause the product to operate on unauthorized files.Failure for a system to check for hard links can result in vulnerability to different types of attacks. For example, an attacker can escalate their privileges if a file used by a privileged program is replaced with a hard link to a sensitive file (e.g. AUTOEXEC.BAT). When the process opens the file, the attacker can assume the privileges of that process, or prevent the program from accurately processing data.",0.4190,61,"The product, when opening a file or directory, does not sufficiently account for when the file is a symbolic link that resolves to a target outside of the intended control sphere. This could allow an attacker to cause the product to operate on unauthorized files.A product that allows UNIX symbolic links (symlink) as part of paths whether in internal code or through user input can allow an attacker to spoof the symbolic link and traverse the file system to unintended locations or access arbitrary files. The symbolic link can permit an attacker to read/write/corrupt a file that they originally did not have permissions to access.",0.4157,62,"The product, when opening a file or directory, does not sufficiently account for when the name is associated with a hard link to a target that is outside of the intended control sphere. This could allow an attacker to cause the product to operate on unauthorized files.Failure for a system to check for hard links can result in vulnerability to different types of attacks. For example, an attacker can escalate their privileges if a file used by a privileged program is replaced with a hard link to a sensitive file (e.g. /etc/passwd). When the process opens the file, the attacker can assume the privileges of that process.",0.4114,38,"The product accepts input in the form of a backslash absolute path ('\absolute\pathname\here') without appropriate validation, which can allow an attacker to traverse the file system to unintended locations or access arbitrary files.",0.4111,57,"The product contains protection mechanisms to restrict access to 'realdir/filename', but it constructs pathnames using external input in the form of 'fakedir/../realdir/filename' that are not handled by those mechanisms. This allows attackers to perform unauthorized actions against the targeted file.",0.4085,553,A possible shell file exists in /cgi-bin/ or other accessible directories. This is extremely dangerous and can be used by an attacker to execute commands on the web server.,0.4059,37,"The product accepts input in the form of a slash absolute path ('/absolute/pathname/here') without appropriate validation, which can allow an attacker to traverse the file system to unintended locations or access arbitrary files.",0.4055
cwe-78,codeql-eg-c-ExecTainted,The main function gets the username from the command line and then uses the `cat` command to get the user information from the system.,True,287,0.0698,"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.This could allow attackers to execute unexpected, dangerous commands directly on the operating system. This weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage.
There are at least two subtypes of OS command injection:
From a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input.",214,"A process is invoked with sensitive command-line arguments, environment variables, or other elements that can be seen by other processes on the operating system.Many operating systems allow a user to list information about processes that are owned by other users. Other users could see information such as command line arguments or environment variable settings. When this data contains sensitive information such as credentials, it might allow other users to launch an attack against the product or related resources.",0.3790,558,"The product uses the getlogin() function in a multithreaded context, potentially causing it to return incorrect values.The getlogin() function returns a pointer to a string that contains the name of the user associated with the calling process. The function is not reentrant, meaning that if it is called from another process, the contents are not locked out and the value of the string can be changed by another process. This makes it very risky to use because the username can be changed by other processes, so the results of the function cannot be trusted.",0.3528,,,,,,,,,,,,,,,,,,,,,,,,
cwe-78,my-1,"The main function gets a directory name from the command line and then lists the contents of that directory using the ""ls"" command line utility.",True,869,-0.0248,"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.This could allow attackers to execute unexpected, dangerous commands directly on the operating system. This weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage.
There are at least two subtypes of OS command injection:
From a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input.",548,"A directory listing is inappropriately exposed, yielding potentially sensitive information to attackers.A directory listing provides an attacker with the complete index of all the resources located inside of the directory. The specific risks and consequences vary depending on which files are listed and accessible.",0.3873,,,,,,,,,,,,,,,,,,,,,,,,,,,
cwe-78,codeql-eg-python-CommandInjection,"The ping function pings a URL to see if it is alive using the ""ping"" system command. It takes the URL to ping as a parameter and runs the ping command using the system command ""ping"". The output of the ping command is returned.",False,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
cwe-79,codeql-eg-Jinja2WithoutEscaping,"The render_response_from_env function takes an Environment object as its argument and returns a Flask response object. The function first gets the name parameter from the request object and then uses it to look up a template in the Environment object. If the template is found, the function renders it with the name parameter and returns a Flask response object with the rendered template as its content.",False,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
cwe-79,codeql-eq-ReflectedXss,The hello function says hello to the user. It takes a username as a parameter and renders a template called hello.html with the username passed in as a variable.,False,,,,1336,"The product uses a template engine to insert or process externally-influenced input, but it does not neutralize or incorrectly neutralizes special elements or syntax that can be interpreted as template expressions or other code directives when processed by the engine.Many web applications use template engines that allow developers to insert externally-influenced values into free text or messages in order to generate a full web page, document, message, etc. Such engines include Twig, Jinja2, Pug, Java Server Pages, FreeMarker, Velocity, ColdFusion, Smarty, and many others - including PHP itself. Some CMS (Content Management Systems) also use templates.
Template engines often have their own custom command or expression language. If an attacker can influence input into a template before it is processed, then the attacker can invoke arbitrary expressions, i.e. perform injection attacks. For example, in some template languages, an attacker could inject the expression ""{{7*7}}"" and determine if the output returns ""49"" instead. The syntax varies depending on the language.
In some cases, XSS-style attacks can work, which can obscure the root cause if the developer does not closely investigate the root cause of the error.
Template engines can be used on the server or client, so both ""sides"" could be affected by injection. The mechanisms of attack or the affected technologies might be different, but the mistake is fundamentally the same.",0.3624,,,,,,,,,,,,,,,,,,,,,,,,,,,
cwe-79,codeql-eg-ExternalAPISinkExample,"The http_hello_page function constructs a response saying ""hello, [username]"" using the PAGE defines.",False,,,,204,"The product provides different responses to incoming requests in a way that reveals internal state information to an unauthorized actor outside of the intended control sphere.This issue frequently occurs during authentication, where a difference in failed-login messages could allow an attacker to determine if the username is valid or not. These exposures can be inadvertent (bug) or intentional (design).",0.4028,598,"The web application uses the HTTP GET method to process a request and includes sensitive information in the query string of that request.The query string for the URL could be saved in the browser's history, passed through Referers to other web sites, stored in web logs, or otherwise recorded in other sources.  If the query string contains sensitive information such as session identifiers, then attackers can use this information to launch further attacks.",0.3573,97,"The product generates a web page, but does not neutralize or incorrectly neutralizes user-controllable input that could be interpreted as a server-side include (SSI) directive.",0.3493,449,The UI performs the wrong action with respect to the user's request.,0.3484,1004,"The product uses a cookie to store sensitive information, but the cookie is not marked with the HttpOnly flag.The HttpOnly flag directs compatible browsers to prevent client-side script from accessing cookies. Including the HttpOnly flag in the Set-Cookie HTTP response header helps mitigate the risk associated with Cross-Site Scripting (XSS) where an attacker's script code might attempt to read the contents of a cookie and exfiltrate information obtained. When set, browsers that support the flag will not reveal the contents of the cookie to a third party via client-side script executed via XSS.",0.3330,,,,,,,,,,,,,,,
cwe-416,mitre-eg-2,"The main function does the following:

1. Allocates a temporary buffer.
2. Stores characters from stdin in the temporary buffer until receiving a newline.
3. If no characters were received, frees the memory and sets an abort flag.
4. If characters were received, stores them in an array.
5. Tidies up by freeing the temporary buffer.",True,15,0.4295,"Referencing memory after it has been freed can cause a program to crash, use unexpected values, or execute code.The use of previously-freed memory can have any number of adverse consequences, ranging from the corruption of valid data to the execution of arbitrary code, depending on the instantiation and timing of the flaw. The simplest way data corruption may occur involves the system's reuse of the freed memory. Use-after-free errors have two common and sometimes overlapping causes:
In this scenario, the memory in question is allocated to another pointer validly at some point after it has been freed. The original pointer to the freed memory is used again and points to somewhere within the new allocation. As the data is changed, it corrupts the validly used memory; this induces undefined behavior in the process.
If the newly allocated data happens to hold a class, in C++ for example, various function pointers may be scattered within the heap data. If one of these function pointers is overwritten with an address to valid shellcode, execution of arbitrary code can be achieved.",466,A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.,0.5727,479,"The product defines a signal handler that calls a non-reentrant function.Non-reentrant functions are functions that cannot safely be called, interrupted, and then recalled before the first call has finished without resulting in memory corruption. This can lead to an unexpected system state and unpredictable results with a variety of potential consequences depending on context, including denial of service and code execution.
Many functions are not reentrant, but some of them can result in the corruption of memory if they are used in a signal handler. The function call syslog() is an example of this. In order to perform its functionality, it allocates a small amount of memory as ""scratch space."" If syslog() is suspended by a signal call and the signal handler calls syslog(), the memory used by both of these functions enters an undefined, and possibly, exploitable state. Implementations of malloc() and free() manage metadata in global structures in order to track which memory is allocated versus which memory is available, but they are non-reentrant. Simultaneous calls to these functions can cause corruption of the metadata.",0.4967,786,"The product reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",0.4893,788,The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.This typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.,0.4872,787,"The product writes data past the end, or before the beginning, of the intended buffer.Typically, this can result in corruption of data, a crash, or code execution.  The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer.  A subsequent write operation then produces undefined or unexpected results.",0.4769,244,"Using realloc() to resize buffers that store sensitive information can leave the sensitive information exposed to attack, because it is not removed from memory.When sensitive data such as a password or an encryption key is not removed from memory, it could be exposed to an attacker using a ""heap inspection"" attack that reads the sensitive data using memory dumps or other methods. The realloc() function is commonly used to increase the size of a block of allocated memory. This operation often requires copying the contents of the old memory block into a new and larger block. This operation leaves the contents of the original block intact but inaccessible to the program, preventing the program from being able to scrub sensitive data from memory. If an attacker can later examine the contents of a memory dump, the sensitive data could be exposed.",0.4720,124,"The product writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",0.4715,805,"The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.When the length value exceeds the size of the destination, a buffer overflow could occur.",0.4602,127,"The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations prior to the targeted buffer.This typically occurs when the pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used. This may result in exposure of sensitive information or possibly a crash.",0.4512,125,"The product reads data past the end, or before the beginning, of the intended buffer.Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash.  A crash can occur when the code reads a variable amount of data and assumes that a sentinel exists to stop the read operation, such as a NUL in a string.  The expected sentinel might not be located in the out-of-bounds memory, causing excessive data to be read, leading to a segmentation fault or a buffer overflow.  The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer.  A subsequent read operation then produces undefined or unexpected results.",0.4481
cwe-416,my-eg-1,"The main function in this code opens a file, reads it into a buffer, calculates the checksum of the buffer, and saves the number of bytes read to the buffer and the checksum to a results file.",False,,,,786,"The product reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",0.4702,788,The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.This typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.,0.4686,466,A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.,0.4456,127,"The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations prior to the targeted buffer.This typically occurs when the pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used. This may result in exposure of sensitive information or possibly a crash.",0.4444,787,"The product writes data past the end, or before the beginning, of the intended buffer.Typically, this can result in corruption of data, a crash, or code execution.  The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer.  A subsequent write operation then produces undefined or unexpected results.",0.4358,124,"The product writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",0.4335,126,The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.This typically occurs when the pointer or its index is incremented to a position beyond the bounds of the buffer or when pointer arithmetic results in a position outside of the valid memory location to name a few. This may result in exposure of sensitive information or possibly a crash.,0.4315,244,"Using realloc() to resize buffers that store sensitive information can leave the sensitive information exposed to attack, because it is not removed from memory.When sensitive data such as a password or an encryption key is not removed from memory, it could be exposed to an attacker using a ""heap inspection"" attack that reads the sensitive data using memory dumps or other methods. The realloc() function is commonly used to increase the size of a block of allocated memory. This operation often requires copying the contents of the old memory block into a new and larger block. This operation leaves the contents of the original block intact but inaccessible to the program, preventing the program from being able to scrub sensitive data from memory. If an attacker can later examine the contents of a memory dump, the sensitive data could be exposed.",0.3953,805,"The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.When the length value exceeds the size of the destination, a buffer overflow could occur.",0.3882,125,"The product reads data past the end, or before the beginning, of the intended buffer.Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash.  A crash can occur when the code reads a variable amount of data and assumes that a sentinel exists to stop the read operation, such as a NUL in a string.  The expected sentinel might not be located in the out-of-bounds memory, causing excessive data to be read, leading to a segmentation fault or a buffer overflow.  The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer.  A subsequent read operation then produces undefined or unexpected results.",0.3796
cwe-416,codeql-UseAfterFree,"The main function in this code gets the buffer size from argv, allocates a buffer, and writes 'a' to the buffer.",False,,,,788,The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.This typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.,0.5129,124,"The product writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",0.4963,131,"The product does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow.",0.4910,786,"The product reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",0.4882,466,A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.,0.4829,787,"The product writes data past the end, or before the beginning, of the intended buffer.Typically, this can result in corruption of data, a crash, or code execution.  The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer.  A subsequent write operation then produces undefined or unexpected results.",0.4528,805,"The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.When the length value exceeds the size of the destination, a buffer overflow could occur.",0.4427,680,"The product performs a calculation to determine how much memory to allocate, but an integer overflow can occur that causes less memory to be allocated than expected, leading to a buffer overflow.",0.4409,127,"The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations prior to the targeted buffer.This typically occurs when the pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used. This may result in exposure of sensitive information or possibly a crash.",0.4165,467,"The code calls sizeof() on a malloced pointer type, which always returns the wordsize/8. This can produce an unexpected result if the programmer intended to determine how much memory has been allocated.The use of sizeof() on a pointer can sometimes generate useful information. An obvious case is to find out the wordsize on a platform. More often than not, the appearance of sizeof(pointer) indicates a bug.",0.4164
cwe-119,mitre-eg-3,The main function prompts the user for the index of a vehicle and returns that vehicle.,True,418,0.1526,"The product performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer.Certain languages allow direct addressing of memory locations and do not automatically ensure that these locations are valid for the memory buffer that is being referenced. This can cause read or write operations to be performed on memory locations that may be associated with other variables, data structures, or internal program data.
As a result, an attacker may be able to execute arbitrary code, alter the intended control flow, read sensitive information, or cause the system to crash.",253,"The product incorrectly checks a return value from a function, which prevents it from detecting errors or exceptional conditions.Important and common functions will return some value about the success of its actions. This will alert the program whether or not to handle any errors caused by that function.",0.3956,1109,"The code contains a callable, block, or other code element in
					which the same variable is used to control more than one unique task or store
					more than one instance of data.Use of the same variable for multiple purposes can make it more difficult for a person to read or understand the code, potentially hiding other quality issues.
This issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities.  It also might make it easier to introduce vulnerabilities.",0.3670,788,The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.This typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.,0.3512,786,"The product reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",0.3504,124,"The product writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",0.3426,562,"A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced.",0.3419,482,"The code uses an operator for comparison when the intention was to perform an assignment.In many languages, the compare statement is very close in appearance to the assignment statement; they are often confused.",0.3320,507,"The product appears to contain benign or useful functionality, but it also contains code that is hidden from normal operation that violates the intended security policy of the user or the system administrator.",0.3288,231,The product does not handle or incorrectly handles when more values are provided than expected.,0.3281,1236,"The product saves user-provided information into a Comma-Separated Value (CSV) file, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as a command when the file is opened by a spreadsheet product.User-provided data is often saved to traditional databases.  This data can be exported to a CSV file, which allows users to read the data using spreadsheet software such as Excel, Numbers, or Calc.  This software interprets entries beginning with '=' as formulas, which are then executed by the spreadsheet software.  The software's formula language often allows methods to access hyperlinks or the local command line, and frequently allows enough characters to invoke an entire script. Attackers can populate data fields which, when saved to a CSV file, may attempt information exfiltration or other malicious activity when automatically executed by the spreadsheet software.",0.3255
cwe-119,my-eg-1,returns the corresponding argument from argv[],True,202,0.0773,"The product performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer.Certain languages allow direct addressing of memory locations and do not automatically ensure that these locations are valid for the memory buffer that is being referenced. This can cause read or write operations to be performed on memory locations that may be associated with other variables, data structures, or internal program data.
As a result, an attacker may be able to execute arbitrary code, alter the intended control flow, read sensitive information, or cause the system to crash.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
cwe-119,codeql-eg-OverflowBuffer,copies the message to the buffer,False,,,,787,"The product writes data past the end, or before the beginning, of the intended buffer.Typically, this can result in corruption of data, a crash, or code execution.  The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer.  A subsequent write operation then produces undefined or unexpected results.",0.3863,294,"A capture-replay flaw exists when the design of the product makes it possible for a malicious user to sniff network traffic and bypass authentication by replaying it to the server in question to the same effect as the original message (or with minor changes).Capture-replay attacks are common and can be difficult to defeat without cryptography. They are a subset of network injection attacks that rely on observing previously-sent valid commands, then changing them slightly if necessary and resending the same commands to the server.",0.3621,422,"The product does not properly verify the source of a message in the Windows Messaging System while running at elevated privileges, creating an alternate channel through which an attacker can directly send a message to the product.",0.3615,805,"The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.When the length value exceeds the size of the destination, a buffer overflow could occur.",0.3615,788,The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.This typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.,0.3547,466,A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.,0.3391,120,"The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.A buffer overflow condition exists when a product attempts to put more data in a buffer than it can hold, or when it attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the ""classic"" case in which the product copies the buffer without restricting how much is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections.",0.3367,123,"Any condition where the attacker has the ability to write an arbitrary value to an arbitrary location, often as the result of a buffer overflow.",0.3328,786,"The product reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",0.3326,124,"The product writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",0.3314
cwe-798,codeql-eg-HardcodedCredentials-c,The get_db_connection function returns a MySQLdb connection object. This object can be used to connect to a MySQL database and perform queries.,False,,,,598,"The web application uses the HTTP GET method to process a request and includes sensitive information in the query string of that request.The query string for the URL could be saved in the browser's history, passed through Referers to other web sites, stored in web logs, or otherwise recorded in other sources.  If the query string contains sensitive information such as session identifiers, then attackers can use this information to launch further attacks.",0.3250,,,,,,,,,,,,,,,,,,,,,,,,,,,
cwe-798,codeql-eg-HardcodedCredentials-b,"The check_mod function checks if the user is a moderator. It does this by querying the database for the username and password provided. If the user is found in the database and their password matches, the function returns ""True"". Otherwise, it returns ""False"".",False,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
cwe-798,codeql-eg-HardcodedCredentials-a,"The check_mod function checks if the user is a moderator. It does this by checking if the username and password match the values of 'root' and 'root', respectively. If they do, the function returns 'true', otherwise it returns 'false'.",True,71,0.1746,"The product contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data.Hard-coded credentials typically create a significant hole that allows an attacker to bypass the authentication that has been configured by the product administrator. This hole might be difficult for the system administrator to detect. Even if detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations:
In the Inbound variant, a default administration account is created, and a simple password is hard-coded into the product and associated with that account. This hard-coded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the product. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the product will have the same password, even across different organizations, this enables massive attacks such as worms to take place.
The Outbound variant applies to front-end systems that authenticate with a back-end service. The back-end service may require a fixed password which can be easily discovered. The programmer may simply hard-code those back-end credentials into the front-end product. Any user of that program may be able to extract the password. Client-side systems with hard-coded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
cwe-306,my-eg-1,"The program defines a route for the user settings page. The route is protected by the ensure_logged_in decorator, which ensures that the user is logged in before they can access the page. The page itself simply returns an HTML page with the text ""Secret settings"".",False,,,,446,"The user interface does not correctly enable or configure a security feature, but the interface provides feedback that causes the user to believe that the feature is in a secure state.When the user interface does not properly reflect what the user asks of it, then it can lead the user into a false sense of security. For example, the user might check a box to enable a security option to enable encrypted communications, but the product does not actually enable the encryption. Alternately, the user might provide a ""restrict ALL"" access control rule, but the product only implements ""restrict SOME"".",0.5155,529,The product stores access control list files in a directory or other container that is accessible to actors outside of the intended control sphere.Exposure of these access control list files may give the attacker information about the configuration of the site or system. This information may then be used to bypass the intended security policy or identify trusted systems from which an attack can be launched.,0.4990,642,"The product stores security-critical state information about its users, or the product itself, in a location that is accessible to unauthorized actors.If an attacker can modify the state information without detection, then it could be used to perform unauthorized actions or access unexpected resources, since the application programmer does not expect that the state can be changed.
State information can be stored in various locations such as a cookie, in a hidden web form field, input parameter or argument, an environment variable, a database record, within a settings file, etc. All of these locations have the potential to be modified by an attacker. When this state information is used to control security or determine resource usage, then it may create a vulnerability. For example, an application may perform authentication, then save the state in an ""authenticated=true"" cookie. An attacker may simply create this cookie in order to bypass the authentication.",0.4943,1231,"The product uses a trusted lock bit for restricting access to registers, address regions, or other resources, but the product does not prevent the value of the lock bit from being modified after it has been set.In integrated circuits and hardware
			  intellectual property (IP) cores, device configuration
			  controls are commonly programmed after a device power
			  reset by a trusted firmware or software module (e.g.,
			  BIOS/bootloader) and then locked from any further
			  modification.
This behavior is commonly implemented using a trusted lock bit. 
			  When set, the lock bit disables writes to a protected set of
			  registers or address regions. Design or coding errors in
			  the implementation of the lock bit protection feature
			  may allow the lock bit to be modified or cleared by
			  software after it has been set. Attackers might be able to unlock the system and
			  features that the bit is intended to protect.",0.4592,1112,"The document does not fully define all mechanisms that are used
					to control or influence how product-specific programs are
					executed.This includes environmental variables, configuration files, registry keys, command-line switches or options, or system settings.",0.4562,784,"The product uses a protection mechanism that relies on the existence or values of a cookie, but it does not properly ensure that the cookie is valid for the associated user.Attackers can easily modify cookies, within the browser or by implementing the client-side code outside of the browser. Attackers can bypass protection mechanisms such as authorization and authentication by modifying the cookie to contain an expected value.",0.4553,565,"The product relies on the existence or values of cookies when performing security-critical operations, but it does not properly ensure that the setting is valid for the associated user.Attackers can easily modify cookies, within the browser or by implementing the client-side code outside of the browser. Reliance on cookies without detailed validation and integrity checking can allow attackers to bypass authentication, conduct injection attacks such as SQL injection and cross-site scripting, or otherwise modify inputs in unexpected ways.",0.4494,1220,"The product implements access controls via a policy or other feature with the intention to disable or restrict accesses (reads and/or writes) to assets in a system from untrusted agents. However, implemented access controls lack required granularity, which renders the control policy too broad because it allows accesses from unauthorized agents to the security-sensitive assets.Integrated circuits and hardware engines can expose accesses to assets (device configuration, keys, etc.) to trusted firmware or a software module (commonly set by BIOS/bootloader). This access is typically access-controlled. Upon a power reset, the hardware or system usually starts with default values in registers, and the trusted firmware (Boot firmware) configures the necessary access-control protection.
A common weakness that can exist in such protection schemes is that access controls or policies are not granular enough. This condition allows agents beyond trusted agents to access assets and could lead to a loss of functionality or the ability to set up the device securely. This further results in security risks from leaked, sensitive, key material to modification of device configuration.",0.4492,539,"The web application uses persistent cookies, but the cookies contain sensitive information.Cookies are small bits of data that are sent by the web application but stored locally in the browser. This lets the application use the cookie to pass information between pages and store variable information. The web application controls what information is stored in a cookie and how it is used. Typical types of information stored in cookies are session identifiers, personalization and customization information, and in rare cases even usernames to enable automated logins. There are two different types of cookies: session cookies and persistent cookies. Session cookies just live in the browser's memory and are not stored anywhere, but persistent cookies are stored on the browser's hard drive.   This can cause security and privacy issues depending on the information stored in the cookie and how it is accessed.",0.4430,1234,"System configuration protection may be bypassed during debug mode.Device configuration controls are commonly programmed after a device power reset by a trusted firmware or software module (e.g., BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set, disables writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration). If debug features supported by hardware or internal modes/system states are supported in the hardware design, modification of the lock protection may be allowed allowing access and modification of configuration information.",0.4399
cwe-306,my-eg-3,"The change_email function is a POST route that allows a user to change their email address. The function first checks that the user is logged in and has provided the current password. If the user is not logged in or has not provided the correct password, the function returns an error message.

If the user is logged in and has provided the correct password, the function checks that the new email address is not the same as the old email address. If the new email address is the same as the old email address, the function returns an error message.

The function then checks that the new and confirm password are the same. If the new and confirm password are not the same, the function returns an error message.

If the new and confirm password are the same, the function updates the user's email address in the database and returns a message confirming that the email address has been changed.",False,,,,620,"When setting a new password for a user, the product does not require knowledge of the original password, or using another form of authentication.This could be used by an attacker to change passwords for another user, thus gaining the privileges associated with that user.",0.3673,640,"The product contains a mechanism for users to recover or change their passwords without knowing the original password, but the mechanism is weak.It is common for an application to have a mechanism that provides a means for a user to gain access to their account in the event they forget their password. Very often the password recovery mechanism is weak, which has the effect of making it more likely that it would be possible for a person other than the legitimate system user to gain access to that user's account. Weak password recovery schemes completely undermine a strong password authentication scheme.
This weakness may be that the security question is too easy to guess or find an answer to (e.g. because the question is too common, or the answers can be found using social media). Or there might be an implementation weakness in the password recovery mechanism code that may for instance trick the system into e-mailing the new password to an e-mail account other than that of the user. There might be no throttling done on the rate of password resets so that a legitimate user can be denied service by an attacker if an attacker tries to recover their password in a rapid succession. The system may send the original password to the user rather than generating a new temporary password. In summary, password recovery functionality, if not carefully designed and implemented can often become the system's weakest link that can be misused in a way that would allow an attacker to gain unauthorized access to the system.",0.3512,393,"A function or operation returns an incorrect return value or status code that does not indicate an error, but causes the product to modify its behavior based on the incorrect result.This can lead to unpredictable behavior. If the function is used to make security-critical decisions or provide security-critical information, then the wrong status code can cause the product to assume that an action is safe, even when it is not.",0.3404,260,"The product stores a password in a configuration file that might be accessible to actors who do not know the password.This can result in compromise of the system for which the password is used. An attacker could gain access to this file and learn the stored password or worse yet, change the password to one of their choosing.",0.3322,,,,,,,,,,,,,,,,,,
cwe-306,my-eg-2,"The admin_page function checks if the user is logged in and if the user is an admin. If the user is not an admin, the function returns a 403 error.",False,,,,756,"The product does not return custom error pages to the user, possibly exposing sensitive information.",0.3747,81,"The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special characters that could be interpreted as web-scripting elements when they are sent to an error page.Error pages may include customized 403 Forbidden or 404 Not Found pages.
When an attacker can trigger an error that contains script syntax within the attacker's input, then cross-site scripting attacks may be possible.",0.3503,12,An ASP .NET application must enable custom error pages in order to prevent attackers from mining information from the framework's built-in responses.,0.3368,425,"The web application does not adequately enforce appropriate authorization on all restricted URLs, scripts, or files.Web applications susceptible to direct request attacks often make the false assumption that such resources can only be reached through a given navigation path and so only apply authorization at certain points in the path.",0.3266,285,"The product does not perform or incorrectly performs an authorization check when an actor attempts to access a resource or perform an action.Assuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user's privileges and any permissions or other access-control specifications that apply to the resource.
When access control checks are not applied consistently - or not at all - users are able to access data or perform actions that they should not be allowed to perform. This can lead to a wide range of problems, including information exposures, denial of service, and arbitrary code execution.",0.3234,863,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.Assuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user's privileges and any permissions or other access-control specifications that apply to the resource.
When access control checks are incorrectly applied, users are able to access data or perform actions that they should not be allowed to perform. This can lead to a wide range of problems, including information exposures, denial of service, and arbitrary code execution.",0.3208,862,"The product does not perform an authorization check when an actor attempts to access a resource or perform an action.Assuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user's privileges and any permissions or other access-control specifications that apply to the resource.
When access control checks are not applied, users are able to access data or perform actions that they should not be allowed to perform. This can lead to a wide range of problems, including information exposures, denial of service, and arbitrary code execution.",0.3203,,,,,,,,,
cwe-89,my-eg-1,The buy_stock function inserts the buy order in the database and calls the buy function to pass stock name.,False,,,,688,"The product calls a function, procedure, or routine, but the caller specifies the wrong variable or reference as one of the arguments, which may lead to undefined behavior and resultant weaknesses.",0.3840,683,"The product calls a function, procedure, or routine, but the caller specifies the arguments in an incorrect order, leading to resultant weaknesses.While this weakness might be caught by the compiler in some languages, it can occur more frequently in cases in which the called function accepts variable numbers or types of arguments, such as format strings in C. It also can occur in languages or environments that do not enforce strong typing.",0.3530,687,"The product calls a function, procedure, or routine, but the caller specifies an argument that contains the wrong value, which may lead to resultant weaknesses.",0.3470,685,"The product calls a function, procedure, or routine, but the caller specifies too many arguments, or too few arguments, which may lead to undefined behavior and resultant weaknesses.",0.3462,562,"A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced.",0.3349,686,"The product calls a function, procedure, or routine, but the caller specifies an argument that is the wrong data type, which may lead to resultant weaknesses.This weakness is most likely to occur in loosely typed languages, or in strongly typed languages in which the types of variable arguments cannot be enforced at compilation time, or where there is implicit casting.",0.3250,,,,,,,,,,,,
cwe-89,codeql-eg-SqlInjection-a,"The unsubscribe function checks if the email (GET variable) is in the database and if so, unsubscribes the user.",False,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
cwe-89,my-eg-2,"The insert_user_message_in_db function inserts a new message into the database. It takes two parameters, username and message, and uses them to construct an SQL INSERT statement. The statement is then executed, and the changes are committed to the database.",True,3,0.3681,"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data. This can be used to alter query logic to bypass security checks, or to insert additional statements that modify the back-end database, possibly including execution of system commands.
SQL injection has become a common issue with database-driven web sites. The flaw is easily detected, and easily exploited, and as such, any site or product package with even a minimal user base is likely to be subject to an attempted attack of this kind. This flaw depends on the fact that SQL makes no real distinction between the control and data planes.",566,"The product uses a database table that includes records that should not be accessible to an actor, but it executes a SQL statement with a primary key that can be controlled by that actor.When a user can set a primary key to any value, then the user can modify the key to point to unauthorized records.
Database access control errors occur when:",0.3892,564,Using Hibernate to execute a dynamic SQL statement built with user-controlled input can allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.,0.3761,89,"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data. This can be used to alter query logic to bypass security checks, or to insert additional statements that modify the back-end database, possibly including execution of system commands.
SQL injection has become a common issue with database-driven web sites. The flaw is easily detected, and easily exploited, and as such, any site or product package with even a minimal user base is likely to be subject to an attempted attack of this kind. This flaw depends on the fact that SQL makes no real distinction between the control and data planes.",0.3681,149,"Quotes injected into a product can be used to compromise a system. As data are parsed, an injected/absent/duplicate/malformed use of quotes may cause the process to take unexpected actions.",0.3285,,,,,,,,,,,,,,,,,,
cwe-20,codeql-eg-IncompleteUrlSubstringSanitization,"The redirect_request function redirects users to the URL in the request, but only if the url is for the ""example.com"" domain.",False,,,,698,"The web application sends a redirect to another location, but instead of exiting, it executes additional code.",0.4643,601,"A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.An http parameter may contain a URL value and could cause the web application to redirect the request to the specified URL. By modifying the URL value to a malicious site, an attacker may successfully launch a phishing scam and steal user credentials. Because the server name in the modified link is identical to the original site, phishing attempts have a more trustworthy appearance. Whether this issue poses a vulnerability will be subject to the intended behavior of the application. For example, a search engine might intentionally provide redirects to arbitrary URLs.",0.4453,449,The UI performs the wrong action with respect to the user's request.,0.3662,1022,"The web application produces links to untrusted external sites outside of its sphere of control, but it does not properly prevent the external site from modifying  security-critical properties of the window.opener object, such as the location property.When a user clicks a link to an external site (""target""), the target=""_blank"" attribute causes the target site's contents to be opened in a new window or tab, which runs in the same process as the original page. The window.opener object records information about the original page that offered the link.  If an attacker can run script on the target page, then they could read or modify certain properties of the window.opener object, including the location property - even if the original and target site are not the same origin.  An attacker can modify the location property to automatically redirect the user to a malicious site, e.g. as part of a phishing attack. Since this redirect happens in the original window/tab - which is not necessarily visible, since the browser is focusing the display on the new target page - the user might not notice any suspicious redirection.",0.3386,,,,,,,,,,,,,,,,,,
cwe-20,my-eg-1,The calculate_sale_value function calculates the value of a sale of a number of shares where the price comes from get_market_price().,True,582,0.0290,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.Input validation is a frequently-used technique
	   for checking potentially dangerous inputs in order to
	   ensure that the inputs are safe for processing within the
	   code, or when communicating with other components.  When
	   software does not validate input properly, an attacker is
	   able to craft the input in a form that is not expected by
	   the rest of the application. This will lead to parts of the
	   system receiving unintended input, which may result in
	   altered control flow, arbitrary control of a resource, or
	   arbitrary code execution.
Input validation is not the only technique for
	   processing input, however.  Other techniques attempt to
	   transform potentially-dangerous input into something safe, such
	   as filtering (CWE-790) - which attempts to remove dangerous
	   inputs - or encoding/escaping (CWE-116), which attempts to
	   ensure that the input is not misinterpreted when it is included
	   in output to another component. Other techniques exist as well
	   (see CWE-138 for more examples.)
Input validation can be applied to:
Data can be simple or structured.  Structured data
	   can be composed of many nested layers, composed of
	   combinations of metadata and raw data, with other simple or
	   structured data.
Many properties of raw data or metadata may need
	   to be validated upon entry into the code, such
	   as:
Implied or derived properties of data must often
	   be calculated or inferred by the code itself.  Errors in
	   deriving properties may be considered a contributing factor
	   to improper input validation.
	   
Note that ""input validation"" has very different
	   meanings to different people, or within different
	   classification schemes.  Caution must be used when
	   referencing this CWE entry or mapping to it.  For example,
	   some weaknesses might involve inadvertently giving control
	   to an attacker over an input when they should not be able
	   to provide an input at all, but sometimes this is referred
	   to as input validation.
Finally, it is important to emphasize that the
	   distinctions between input validation and output escaping
	   are often blurred, and developers must be careful to
	   understand the difference, including how input validation
	   is not always sufficient to prevent vulnerabilities,
	   especially when less stringent data types must be
	   supported, such as free-form text. Consider a SQL injection
	   scenario in which a person's last name is inserted into a
	   query. The name ""O'Reilly"" would likely pass the validation
	   step since it is a common last name in the English
	   language. However, this valid name cannot be directly
	   inserted into the database because it contains the ""'""
	   apostrophe character, which would need to be escaped or
	   otherwise transformed. In this case, removing the
	   apostrophe might reduce the risk of SQL injection, but it
	   would produce incorrect behavior because the wrong name
	   would be recorded.",193,"A product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.",0.3669,469,"The product subtracts one pointer from another in order to determine size, but this calculation can be incorrect if the pointers do not exist in the same memory chunk.",0.3582,687,"The product calls a function, procedure, or routine, but the caller specifies an argument that contains the wrong value, which may lead to resultant weaknesses.",0.3198,,,,,,,,,,,,,,,,,,,,,
cwe-20,codeql-eg-IncompleteHostnameRegExp,"The safe function checks if the URL passed in the request is for the example.com domain. If it is, the function redirects the user to that URL. If it is not, the function redirects the user to the homepage.",False,,,,1022,"The web application produces links to untrusted external sites outside of its sphere of control, but it does not properly prevent the external site from modifying  security-critical properties of the window.opener object, such as the location property.When a user clicks a link to an external site (""target""), the target=""_blank"" attribute causes the target site's contents to be opened in a new window or tab, which runs in the same process as the original page. The window.opener object records information about the original page that offered the link.  If an attacker can run script on the target page, then they could read or modify certain properties of the window.opener object, including the location property - even if the original and target site are not the same origin.  An attacker can modify the location property to automatically redirect the user to a malicious site, e.g. as part of a phishing attack. Since this redirect happens in the original window/tab - which is not necessarily visible, since the browser is focusing the display on the new target page - the user might not notice any suspicious redirection.",0.5309,601,"A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.An http parameter may contain a URL value and could cause the web application to redirect the request to the specified URL. By modifying the URL value to a malicious site, an attacker may successfully launch a phishing scam and steal user credentials. Because the server name in the modified link is identical to the original site, phishing attempts have a more trustworthy appearance. Whether this issue poses a vulnerability will be subject to the intended behavior of the application. For example, a search engine might intentionally provide redirects to arbitrary URLs.",0.5292,79,"The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.Cross-site scripting (XSS) vulnerabilities occur when:
There are three main kinds of XSS:
Once the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as ""drive-by hacking.""
In many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.",0.4945,242,"The product calls a function that can never be guaranteed to work safely.Certain functions behave in dangerous ways regardless of how they are used. Functions in this category were often implemented without taking security concerns into account. The gets() function is unsafe because it does not perform bounds checking on the size of its input. An attacker can easily send arbitrarily-sized input to gets() and overflow the destination buffer. Similarly, the >> operator is unsafe to use when reading into a statically-allocated character array because it does not perform bounds checking on the size of its input. An attacker can easily send arbitrarily-sized input to the >> operator and overflow the destination buffer.",0.4663,1289,"The product receives an input value that is used as a resource identifier or other type of reference, but it does not validate or incorrectly validates that the input is equivalent to a potentially-unsafe value.Attackers can sometimes bypass input validation schemes by finding inputs that appear to be safe, but will be dangerous when processed at a lower layer or by a downstream component.  For example, a simple XSS protection mechanism might try to validate that an input has no ""<script>"" tags using case-sensitive matching, but since HTML is case-insensitive when processed by web browsers, an attacker could inject ""<ScrIpT>"" and trigger XSS.",0.4533,393,"A function or operation returns an incorrect return value or status code that does not indicate an error, but causes the product to modify its behavior based on the incorrect result.This can lead to unpredictable behavior. If the function is used to make security-critical decisions or provide security-critical information, then the wrong status code can cause the product to assume that an action is safe, even when it is not.",0.4531,356,"The product's user interface does not warn the user before undertaking an unsafe action on behalf of that user. This makes it easier for attackers to trick users into inflicting damage to their system.Product systems should warn users that a potentially dangerous action may occur if the user proceeds. For example, if the user downloads a file from an unknown source and attempts to execute the file on their machine, then the application's GUI can indicate that the file is unsafe.",0.4504,676,"The product invokes a potentially dangerous function that could introduce a vulnerability if it is used incorrectly, but the function can also be used safely.",0.4447,598,"The web application uses the HTTP GET method to process a request and includes sensitive information in the query string of that request.The query string for the URL could be saved in the browser's history, passed through Referers to other web sites, stored in web logs, or otherwise recorded in other sources.  If the query string contains sensitive information such as session identifiers, then attackers can use this information to launch further attacks.",0.4235,1275,"The SameSite attribute for sensitive cookies is not set, or an insecure value is used.The SameSite attribute controls how cookies are sent for cross-domain requests. This attribute may have three values: 'Lax', 'Strict', or 'None'. If the 'None' value is used, a website may create a cross-domain POST HTTP request to another website, and the browser automatically adds cookies to this request. This may lead to Cross-Site-Request-Forgery (CSRF) attacks if there are no additional protections in place (such as Anti-CSRF tokens).",0.4170
cwe-476,codeql-eg-MissingNullTest-b,The main function allocates a new person and sets its status to 0.,True,329,0.1108,"A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.NULL pointer dereference issues can occur through a number of flaws, including race conditions, and simple programming omissions.",466,A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.,0.3397,,,,,,,,,,,,,,,,,,,,,,,,,,,
cwe-476,codeql-eg-MissingNullTest-c,The main function in this code allocates a large buffer and copies 100 characters from stdin into it.,True,425,0.1157,"A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.NULL pointer dereference issues can occur through a number of flaws, including race conditions, and simple programming omissions.",805,"The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.When the length value exceeds the size of the destination, a buffer overflow could occur.",0.4911,131,"The product does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow.",0.4861,244,"Using realloc() to resize buffers that store sensitive information can leave the sensitive information exposed to attack, because it is not removed from memory.When sensitive data such as a password or an encryption key is not removed from memory, it could be exposed to an attacker using a ""heap inspection"" attack that reads the sensitive data using memory dumps or other methods. The realloc() function is commonly used to increase the size of a block of allocated memory. This operation often requires copying the contents of the old memory block into a new and larger block. This operation leaves the contents of the original block intact but inaccessible to the program, preventing the program from being able to scrub sensitive data from memory. If an attacker can later examine the contents of a memory dump, the sensitive data could be exposed.",0.4432,787,"The product writes data past the end, or before the beginning, of the intended buffer.Typically, this can result in corruption of data, a crash, or code execution.  The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer.  A subsequent write operation then produces undefined or unexpected results.",0.4315,466,A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.,0.4295,806,"The product uses the size of a source buffer when reading from or writing to a destination buffer, which may cause it to access memory that is outside of the bounds of the buffer.When the size of the destination is smaller than the size of the source, a buffer overflow could occur.",0.4191,680,"The product performs a calculation to determine how much memory to allocate, but an integer overflow can occur that causes less memory to be allocated than expected, leading to a buffer overflow.",0.3954,123,"Any condition where the attacker has the ability to write an arbitrary value to an arbitrary location, often as the result of a buffer overflow.",0.3895,125,"The product reads data past the end, or before the beginning, of the intended buffer.Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash.  A crash can occur when the code reads a variable amount of data and assumes that a sentinel exists to stop the read operation, such as a NUL in a string.  The expected sentinel might not be located in the out-of-bounds memory, causing excessive data to be read, leading to a segmentation fault or a buffer overflow.  The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer.  A subsequent read operation then produces undefined or unexpected results.",0.3879,788,The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.This typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.,0.3873
cwe-476,codeql-eg-MissingNullTest-a,The main function allocates a new person and sets its status to 0.,True,329,0.1108,"A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.NULL pointer dereference issues can occur through a number of flaws, including race conditions, and simple programming omissions.",466,A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.,0.3397,,,,,,,,,,,,,,,,,,,,,,,,,,,
cwe-200,mitre-eg-1,"The login function logs in the user if the username and password are correct. It does this by first connecting to the database and then executing a SQL query to select all rows from the users table where the username and password match the values provided in the request. If the query returns any results, then the function logs the user in by setting the session variables id and Role to the values of the first row returned by the query.",False,,,,523,Login pages do not use adequate measures to protect the user name and password while they are in transit from the client to the server.,0.4077,598,"The web application uses the HTTP GET method to process a request and includes sensitive information in the query string of that request.The query string for the URL could be saved in the browser's history, passed through Referers to other web sites, stored in web logs, or otherwise recorded in other sources.  If the query string contains sensitive information such as session identifiers, then attackers can use this information to launch further attacks.",0.3644,558,"The product uses the getlogin() function in a multithreaded context, potentially causing it to return incorrect values.The getlogin() function returns a pointer to a string that contains the name of the user associated with the calling process. The function is not reentrant, meaning that if it is called from another process, the contents are not locked out and the value of the string can be changed by another process. This makes it very risky to use because the username can be changed by other processes, so the results of the function cannot be trusted.",0.3604,539,"The web application uses persistent cookies, but the cookies contain sensitive information.Cookies are small bits of data that are sent by the web application but stored locally in the browser. This lets the application use the cookie to pass information between pages and store variable information. The web application controls what information is stored in a cookie and how it is used. Typical types of information stored in cookies are session identifiers, personalization and customization information, and in rare cases even usernames to enable automated logins. There are two different types of cookies: session cookies and persistent cookies. Session cookies just live in the browser's memory and are not stored anywhere, but persistent cookies are stored on the browser's hard drive.   This can cause security and privacy issues depending on the information stored in the cookie and how it is accessed.",0.3493,836,"The product records password hashes in a data store, receives a hash of a password from a client, and compares the supplied hash to the hash obtained from the data store.Some authentication mechanisms rely on the client to generate the hash for a password, possibly to reduce load on the server or avoid sending the password across the network. However, when the client is used to generate the hash, an attacker can bypass the authentication by obtaining a copy of the hash, e.g. by using SQL injection to compromise a database of authentication credentials, or by exploiting an information exposure. The attacker could then use a modified client to replay the stolen hash without having knowledge of the original password.
As a result, the server-side comparison against a client-side hash does not provide any more security than the use of passwords without hashing.",0.3491,532,"Information written to log files can be of a sensitive nature and give valuable guidance to an attacker or expose sensitive user information.While logging all information may be helpful during development stages, it is important that logging levels be set appropriately before a product ships so that sensitive user data and system information are not accidentally exposed to potential attackers.
Different log files may be produced and stored for:",0.3427,384,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.Such a scenario is commonly observed when:",0.3404,202,"When trying to keep information confidential, an attacker can often infer some of the information by using statistics.In situations where data should not be tied to individual users, but a large number of users should be able to make queries that ""scrub"" the identity of users, it may be possible to get information about a user -- e.g., by specifying search terms that are known to be unique to that user.",0.3374,204,"The product provides different responses to incoming requests in a way that reveals internal state information to an unauthorized actor outside of the intended control sphere.This issue frequently occurs during authentication, where a difference in failed-login messages could allow an attacker to determine if the username is valid or not. These exposures can be inadvertent (bug) or intentional (design).",0.3359,289,"The product performs authentication based on the name of a resource being accessed, or the name of the actor performing the access, but it does not properly check all possible names for that resource or actor.",0.3263
cwe-522,my-eg-1-c,"The register function gets the username, password, first name, last name, and email from the user and checks if the username is already in the database. If the username is not in the database, the function inserts the username and hashed password into the database and returns a success message.",True,22,0.2628,"The product transmits or stores authentication credentials, but it uses an insecure method that is susceptible to unauthorized interception and/or retrieval.",1283,"The register contents used for attestation or measurement reporting data to verify boot flow are modifiable by an adversary.A System-on-Chip (SoC) implements secure boot or verified boot. During this boot flow, the SoC often measures the code that it authenticates. The measurement is usually done by calculating the one-way hash of the code binary and extending it to the previous hash. The hashing algorithm should be a Secure One-Way hash function. The final hash, i.e., the value obtained after the completion of the boot flow, serves as the measurement data used in reporting or in attestation. The calculated hash is often stored in registers that can later be read by the party of interest to determine tampering of the boot flow. A common weakness is that the contents in these registers are modifiable by an adversary, thus spoofing the measurement.",0.4053,558,"The product uses the getlogin() function in a multithreaded context, potentially causing it to return incorrect values.The getlogin() function returns a pointer to a string that contains the name of the user associated with the calling process. The function is not reentrant, meaning that if it is called from another process, the contents are not locked out and the value of the string can be changed by another process. This makes it very risky to use because the username can be changed by other processes, so the results of the function cannot be trusted.",0.3322,836,"The product records password hashes in a data store, receives a hash of a password from a client, and compares the supplied hash to the hash obtained from the data store.Some authentication mechanisms rely on the client to generate the hash for a password, possibly to reduce load on the server or avoid sending the password across the network. However, when the client is used to generate the hash, an attacker can bypass the authentication by obtaining a copy of the hash, e.g. by using SQL injection to compromise a database of authentication credentials, or by exploiting an information exposure. The attacker could then use a modified client to replay the stolen hash without having knowledge of the original password.
As a result, the server-side comparison against a client-side hash does not provide any more security than the use of passwords without hashing.",0.3300,,,,,,,,,,,,,,,,,,,,,
cwe-522,my-eg-1-b,"
#register url
@app.route('/register', methods=['POST'])
def register():
   username = request.form['username']
   password = request.form['password']
   #hash the password
   salt = os.urandom(16)
   password = password.encode('utf-8')
   password = salt + password
   password = hashlib.sha256(password)
   password = password.hexdigest()

   db = MySQLdb.connect(host='localhost', user='root', passwd='', db='users')
   cursor = db.cursor()
   cursor.execute(""SELECT * FROM user_details WHERE username = '""+username+""'"")
   data = cursor.fetchone()
   if(len(data) > 0):
      print('Username already exists, try a different one')
      return redirect('/register')
   else:
      cursor.execute(""INSERT INTO user_details (username, password, salt, email) VALUES ('""+username+""', '""+password+""', '""+salt+""', '')"")
      db.commit()
      return redirect('/login')

The register function does the following:

1. Gets the username and password from the request.
2. Hashes the password.
3. Checks if the username already exists in the database.
4. If the username does not exist, inserts the username, password, and salt into the database.
5. Redirects the user to the login page.",True,52,0.1088,"The product transmits or stores authentication credentials, but it uses an insecure method that is susceptible to unauthorized interception and/or retrieval.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
cwe-522,my-eg-1-a,The register function inserts a new user into the database. It takes the username and password from the request and hashes the password before inserting it into the database.,True,16,0.3057,"The product transmits or stores authentication credentials, but it uses an insecure method that is susceptible to unauthorized interception and/or retrieval.",620,"When setting a new password for a user, the product does not require knowledge of the original password, or using another form of authentication.This could be used by an attacker to change passwords for another user, thus gaining the privileges associated with that user.",0.4173,1283,"The register contents used for attestation or measurement reporting data to verify boot flow are modifiable by an adversary.A System-on-Chip (SoC) implements secure boot or verified boot. During this boot flow, the SoC often measures the code that it authenticates. The measurement is usually done by calculating the one-way hash of the code binary and extending it to the previous hash. The hashing algorithm should be a Secure One-Way hash function. The final hash, i.e., the value obtained after the completion of the boot flow, serves as the measurement data used in reporting or in attestation. The calculated hash is often stored in registers that can later be read by the party of interest to determine tampering of the boot flow. A common weakness is that the contents in these registers are modifiable by an adversary, thus spoofing the measurement.",0.4003,260,"The product stores a password in a configuration file that might be accessible to actors who do not know the password.This can result in compromise of the system for which the password is used. An attacker could gain access to this file and learn the stored password or worse yet, change the password to one of their choosing.",0.3544,1233,"The product uses a register lock bit protection mechanism, but it does not ensure that the lock bit prevents modification of system registers or controls that perform changes to important hardware system configuration.Integrated circuits and hardware intellectual properties (IPs) might provide device configuration controls that need to be programmed after device power reset by a trusted firmware or software module, commonly set by BIOS/bootloader. After reset, there can be an expectation that the controls cannot be used to perform any further modification. This behavior is commonly implemented using a trusted lock bit, which can be set to disable writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration).
However, if the lock bit does not effectively write-protect all system registers or controls that could modify the protected system configuration, then an adversary may be able to use software to access the registers/controls and modify the protected hardware configuration.",0.3505,1262,"The product uses memory-mapped I/O registers that act as an interface to hardware functionality from software, but there is improper access control to those registers.Software commonly accesses peripherals in a System-on-Chip (SoC) or other device through a memory-mapped register interface. Malicious software could tamper with any security-critical hardware data that is accessible directly or indirectly through the register interface, which could lead to a loss of confidentiality and integrity.",0.3428,836,"The product records password hashes in a data store, receives a hash of a password from a client, and compares the supplied hash to the hash obtained from the data store.Some authentication mechanisms rely on the client to generate the hash for a password, possibly to reduce load on the server or avoid sending the password across the network. However, when the client is used to generate the hash, an attacker can bypass the authentication by obtaining a copy of the hash, e.g. by using SQL injection to compromise a database of authentication credentials, or by exploiting an information exposure. The attacker could then use a modified client to replay the stolen hash without having knowledge of the original password.
As a result, the server-side comparison against a client-side hash does not provide any more security than the use of passwords without hashing.",0.3395,1232,"Register lock bit protection disables changes to system configuration once the bit is set. Some of the protected registers or lock bits become programmable after power state transitions (e.g., Entry and wake from low power sleep modes) causing the system configuration to be changeable.Devices may allow device configuration controls which need to be programmed after device power reset via a trusted firmware or software module (commonly set by BIOS/bootloader) and then locked from any further modification. This action is commonly implemented using a programmable lock bit, which, when set, disables writes to a protected set of registers or address regions.
After a power state transition, the lock bit is set to unlocked. Some common weaknesses that can exist in such a protection scheme are that the lock gets cleared, the values of the protected registers get reset, or the lock become programmable.",0.3384,1223,"A write-once register in hardware design is programmable by an untrusted software component earlier than the trusted software component, resulting in a race condition issue.Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to defined default values that are hard coded in the hardware description language (HDL) code of the hardware unit. A common security protection method used to protect register settings from modification by software is to make them write-once. This means the hardware implementation only allows writing to such registers once, and they become read-only after having been written once by software. This is useful to allow initial boot software to configure systems settings to secure values while blocking runtime software from modifying such hardware settings.
Implementation issues in hardware design of such controls can expose such registers to a race condition security flaw. For example, consider a hardware design that has two different software/firmware modules executing in parallel. One module is trusted (module A) and another is untrusted (module B). In this design it could be possible for Module B to send write cycles to the write-once register before Module A. Since the field is write-once the programmed value from Module A will be ignored and the pre-empted value programmed by Module B will be used by hardware.",0.3360,521,"The product does not require that users should have strong passwords, which makes it easier for attackers to compromise user accounts.Authentication mechanisms often rely on a memorized secret (also known as a password) to provide an assertion of identity for a user of a system. It is therefore important that this password be of sufficient complexity and impractical for an adversary to guess. The specific requirements around how complex a password needs to be depends on the type of system being protected. Selecting the correct password requirements and enforcing them through implementation are critical to the overall success of the authentication mechanism.",0.3246,645,"The product contains an account lockout protection mechanism, but the mechanism is too restrictive and can be triggered too easily, which allows attackers to deny service to legitimate users by causing their accounts to be locked out.Account lockout is a security feature often present in applications as a countermeasure to the brute force attack on the password based authentication mechanism of the system. After a certain number of failed login attempts, the users' account may be disabled for a certain period of time or until it is unlocked by an administrator. Other security events may also possibly trigger account lockout. However, an attacker may use this very security feature to deny service to legitimate system users. It is therefore important to ensure that the account lockout security mechanism is not overly restrictive.",0.3246
cwe-502,codeql-eg-UnsafeDeserialization-c,"The calculate_price function takes a product code and quantity as input, and returns the total price. The function first gets the price for the product code from the get_price_for_product_code function. Then, it multiplies the price by the quantity to get the total price.",False,,,,688,"The product calls a function, procedure, or routine, but the caller specifies the wrong variable or reference as one of the arguments, which may lead to undefined behavior and resultant weaknesses.",0.3645,193,"A product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.",0.3489,482,"The code uses an operator for comparison when the intention was to perform an assignment.In many languages, the compare statement is very close in appearance to the assignment statement; they are often confused.",0.3478,687,"The product calls a function, procedure, or routine, but the caller specifies an argument that contains the wrong value, which may lead to resultant weaknesses.",0.3317,685,"The product calls a function, procedure, or routine, but the caller specifies too many arguments, or too few arguments, which may lead to undefined behavior and resultant weaknesses.",0.3260,1284,"The product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.Specified quantities include size, length, frequency, price, rate, number of operations, time, and others. Code may rely on specified quantities to allocate resources, perform calculations, control iteration, etc. When the quantity is not properly validated, then attackers can specify malicious quantities to cause excessive resource allocation, trigger unexpected failures, enable buffer overflows, etc.",0.3194,,,,,,,,,,,,
cwe-502,codeql-eg-UnsafeDeserialization-b,The temperature_for_location function gets the latitude and longitude and date from the incoming YAML payload and returns the temperature from the database.,False,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
